#!/usr/bin/zsh

# Automatically download and switch kubenetes-cli according to the cluster version
# This was Nan's script but I've adapted it NOT to run the command directly. Just prep the binary
_k5l() {
    if ! hash kubectl 2>/dev/null; then
        echo "Pleast install latest version kubectl first. e.g. brew install kubectl"
    fi

    # Command that not required a cluser are escaped here
    if [[ $* =~ ([[:space:]]*)(config|help|completion|options)([[:space:]]*) ]]
    then
        # command kubectl $@
        return
    fi

    local context=""
    if [[ $* =~ --context(=|[[:space:]]*)([^[:space:]]*) ]]
    then
        context="${match[2]}${BASH_REMATCH[2]}"
    fi

    if [ -f ~/bin/kubectl-$context ]
    then
        ~/bin/kubectl-$context $@
    else
        # download binary if necessary
        context_arg=""
        if [ ! -z "$context" ]
        then
            context_arg="--context=$context"
        fi

        local server_version_str=$(command kubectl $context_arg version | tail -1)
        local server_version=""
        if [[ $server_version_str = Server* && $server_version_str =~ GitVersion:\"v([^\"]*)\" ]]
        then
            server_version="${match[1]}${BASH_REMATCH[1]}"
            local platform=$([[ $OSTYPE == *darwin* ]] && echo "darwin" || echo "linux")
            [ -d ~/bin/ ] || mkdir -p ~/bin/
            echo "k5l: dowloading kubectl $server_version for context $context ..."
            curl -# -Lo ~/bin/kubectl-$context "https://storage.googleapis.com/kubernetes-release/release/v$server_version/bin/$platform/amd64/kubectl"
            chmod +x ~/bin/kubectl-$context
            echo "k5l: done. To update the client binary please delete ~/bin/kubectl-$context"
            # ~/bin/kubectl-$context $@
        else
            echo "k5l: server version unavaliable"
        fi
    fi
}

function kb {
  context="$1"
  shift
  for i
  do
     kubectl --context=$context scale --replicas=0 deployment/$i
     kubectl --context=$context scale --replicas=1 deployment/$i
  done
  #clicache -del kubectl --context=$context get pod --no-headers
}

function ki {
  #clicache kubectl --context=$1 get pod -l "app=$2" --no-headers | cut -d ' ' -f1
  echo -n "$1 "
  kubectl-$1 --context=$1 get pod --no-headers | grep $2 | head -1| cut -d ' ' -f1
}

function kcc {
  rm -rf ~/.cache/clicache/*
}

function k {
  kubectl-$1 --context=$1 ${@:2}
}

function kpg {
  kubectl-$1 --context=$1 get pod ${@:2}
}
alias kgp=kpg

function kpn {
  kubectl --context=$1 get pod -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' ${@:2}
}

function kpi {
  export POD=$(kubectl --context=$1 get pod -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' ${@:2}|vipe)
  export CTXPOD="$1 $POD" 
}

function kpa {
  kubectl-$1 --context=$1 get pod -l "app=${@:2}" --no-headers
}

function kw {
  watch kubectl-$1 --context=$1 get pod
}

function kbw {
  kb ${@:1}
  kw ${@:1}
}

function kx {
  kubectl-$1 --context=$1 exec -it $2 -- ${@:3}
}


function ksh {
  kubectl-$1 --context=$1 exec -it $2 -- sh ${@:3}
}

function kl {
  kubectl-$1 --context=$1 log ${@:2}
}

function ka {
  kubectl-$1 --context=$1 apply -f ${@:2}
}

function kr {
  kubectl-$1 --context=$1 replace --cascade --force -f ${@:2}
}

function kpf {
  kubectl --context=$1 port-forward ${@:2}
}

function kp {
  kubectl --context=$1 patch deployment $2 -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"redeployTimestamp\": \"$(date -u -R)\"}}}}}"
}
