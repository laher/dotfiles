#!/usr/bin/zsh

function kubectl-env {
  case $1 in
  *dd) # fallthrough
    ;&
  tools)
    echo kubectl-1.10.6
    ;;
  *us)
    echo kubectl-1.5.2
    ;;
  *fr) # fallthrough
    ;&
  *cn)
    echo kubectl-1.7.4
    ;;
  *)
    echo kubectl
    ;;
  esac
}

function kubectl-ctx {
  echo "$(kubectl-env $1) --context=$1"
}

function ki {
  #clicache kubectl --context=$1 get pod -l "app=$2" --no-headers | cut -d ' ' -f1
  echo -n "$1 "
  $(kubectl-ctx $1) get pod --no-headers | grep $2 | head -1| cut -d ' ' -f1
}

function k {
  case $2 in
  +gp)
    $(kubectl-ctx $1) get pod ${@:3}
    ;;
  +gpn)
    $(kubectl-ctx $1) get pod -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' ${@:3}
    ;;
  +gpi)
    $(kubectl-ctx $1) get pod -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' ${@:3} |vipe
    ;;
  +x)
    $(kubectl-ctx $1) exec -it $3 -- ${@:4}
    ;;
  +sh)
    $(kubectl-ctx $1) exec -it $3 -- sh ${@:4}
    ;;
  +a)
    $(kubectl-ctx $1) apply -f ${@:3}
    ;;
  +r)
    $(kubectl-ctx $1) replace --cascade --force -f ${@:3}
    ;;
  +l)
    $(kubectl-ctx $1) log ${@:3}
    ;;
  +f)
    $(kubectl-ctx $1) log --tail=10 -f ${@:3}
    ;;
  +p)
    $(kubectl-ctx $1) patch deployment $3 -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"redeployTimestamp\": \"$(date -u -R)\"}}}}}"
    ;;
  +pw)
    $(kubectl-ctx $1) patch deployment $3 -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"redeployTimestamp\": \"$(date -u -R)\"}}}}}"
    $(kubectl-ctx $1) get pod --watch
    ;;
  +pf)
    $(kubectl-ctx $1) port-forward ${@:3}
    ;;
  *)
    $(kubectl-ctx $1) ${@:2}
    ;;
  esac
}

function kpi {
  export POD=$(kubectl --context=$1 get pod -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' ${@:2}|vipe)
  export CTXPOD="$1 $POD" 
}

function kpa {
  $(kubectl-env $1) --context=$1 get pod -l "app=${@:2}" --no-headers
}

# Automatically download and switch kubenetes-cli according to the cluster version
# This was Nan's script but I've adapted it NOT to run the command directly. Just prep the binary
_k5l() {
    if ! hash kubectl 2>/dev/null; then
        echo "Pleast install latest version kubectl first. e.g. brew install kubectl"
    fi

    # Command that not required a cluser are escaped here
    if [[ $* =~ ([[:space:]]*)(config|help|completion|options)([[:space:]]*) ]]
    then
        # command kubectl $@
        return
    fi

    local context=""
    if [[ $* =~ --context(=|[[:space:]]*)([^[:space:]]*) ]]
    then
        context="${match[2]}${BASH_REMATCH[2]}"
    fi

    if [ -f ~/bin/kubectl-$context ]
    then
        ~/bin/kubectl-$context $@
    else
        # download binary if necessary
        context_arg=""
        if [ ! -z "$context" ]
        then
            context_arg="--context=$context"
        fi

        local server_version_str=$(command kubectl $context_arg version | tail -1)
        local server_version=""
        if [[ $server_version_str = Server* && $server_version_str =~ GitVersion:\"v([^\"]*)\" ]]
        then
            server_version="${match[1]}${BASH_REMATCH[1]}"
            local platform=$([[ $OSTYPE == *darwin* ]] && echo "darwin" || echo "linux")
            [ -d ~/bin/ ] || mkdir -p ~/bin/
            echo "k5l: dowloading kubectl $server_version for context $context ..."
            curl -# -Lo ~/bin/kubectl-$context "https://storage.googleapis.com/kubernetes-release/release/v$server_version/bin/$platform/amd64/kubectl"
            chmod +x ~/bin/kubectl-$context
            echo "k5l: done. To update the client binary please delete ~/bin/kubectl-$context"
            # ~/bin/kubectl-$context $@
        else
            echo "k5l: server version unavaliable"
        fi
    fi
}
